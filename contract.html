<html>
<head>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta2/css/all.min.css" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/base16/rebecca.min.css" rel="stylesheet">
<link href="/style.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.7.1/web3.min.js"></script>
<script src="https://unpkg.com/c0js/dist/c0.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/handlebars.js/4.7.7/handlebars.min.js"></script>
<script src="/config.js"></script>
<script id="empty-template" type="text/x-handlebars-template">
<div class='form'>
<h1>Deploy Contract</h1>
<div>
  <div>Get started by deploying this contract.</div>
  <br>
  <form id='deploy'>
    <input class='input-field' id='name' type='text' placeholder='name'>
    <input class='input-field' id='symbol' type='text' placeholder='symbol'>
    <input id='submit' type='submit' class='btn' value='deploy'>
    <div class='loading hidden'>
      <img class='rotate' src='/cell_logo.png'> loading...
    </div>
  </form>
</div>
</div>
</script>
<script id="deployed-template" type="text/x-handlebars-template">
<div>
  <h3>Introduction</h3>
  <div>With Cell, NFTs can exist both offchain and onchain. When offchain tokens are recorded onto the blockchain through minting, they become "onchain tokens".</div>
  <br>
  <div>Tokens can ONLY be minted to the contracts they were created for. To enforce this, each token contains a piece of metadata made up of the following 3 attributes:</div>
  <ol>
    <li><code>address</code>: the contract address</li>
    <li><code>chainId</code>: the <a href="https://chainlist.org/">chainId</a> used to describe the host blockchain (ex: 1 for Ethereum mainnet, 4 for Rinkeby)</li>
    <li><code>name</code>: the name of the contract specified when you deployed the NFT contract</li>
  </ol>
  <div>These 3 attributes are called a <code>"domain"</code> of a token.</div>
  <blockquote>When working with Cell NFT contracts, you will often need to provide the domain information to provide context around tokens.</blockquote>
  <div>This NFT contract has the following domain. You will need to use this whenever you create or mint tokens:</div>
  <pre class='code' id='domain'>{{domain}}</pre>
</div>
<hr>
<div>
  <h3>Quickstart</h3>
  <div>Here are the next steps:</div>
  <ol>
    <li><b>Setup:</b> Install and setup Nuron, an app that lets you programmatically create and manage Cell NFTs.</li>
    <li><b>Create tokens:</b> Learn to use <code>nuron.js</code> to make requests to Nuron to create tokens.</li>
    <li><b>Browse and manage tokens:</b> learn how the nuron file system stores and lets you manage tokens.</li>
    <li><b>Mint tokens:</b> Learn how to publish the tokens and the built-in minting website, and mint from it./li>
  </ol>
</div>
<hr>
<div>
  <h3>1. Setup</h3>
  <blockquote><h4>What is Nuron?</h4><br>To create an NFT collection with lots of tokens, we need a programmatic way to sign tokens. Nobody wants to sit there and manually sign 10,000 Metamask popups to create individual tokens. This is especially the case when we have a powerful protocol that lets you program each token individually, each with its own distinct logic. Cell is such a protocol, and to take advantage of all the features, we need an automated and flexible way to sign messages.<br><br>This is where "Nuron" comes in. It is a programmable wallet that can sign all kinds of messages automatically. Additionally, Nuron includes a native file system that stores all the NFT related IPFS files locally as well as programmatically pin them to the global IPFS network whenever you want.</blockquote>
  <div class='section'>
    <h4>1. Install Nuron</h4>
    <br>
    <div>Nuron lets you automatically and programmatically generate NFTs</div>
    <br>
    <pre class='code'>npm install -g nuron</pre>
    <blockquote>If above command fails with a permission error, try:<br><pre class='code'>npm install -g nuron --unsafe-perm</pre><br>If it still fails, try updating the node.js version to the latest.
    </blockquote>
  </div>
  <div class='section'>
    <h4>2. Run Nuron</h4>
    <br>
    <div>Start nuron with the following command:</div>
    <br>
    <pre class='code'>nuron start</pre>
    <br>
    <div>Or if you want to run it in the background, run the following command:</div>
    <br>
    <pre class='code'>nohup nuron start &</pre>
  </div>
  <div class='section'>
    <h4>3. Configure Nuron</h4>
    <br>
    <div>You need to configure Nuron first. Run the following command to connect to and configure Nuron:</div>
    <pre class='code'>nuron config</pre>
    <div>Make sure to configure both of the following:</div>
    <ol>
      <li><b>Import a wallet:</b> You MUST use the same address that deployed this contract. Export the seed phrase from the wallet you used to deploy this collection, and import it into Nuron./li>
      <li>Set nft.storage IPFS config</li>
    </ol>
    <br>
  </div>
</div>
<hr>
<div>
  <h3>2. Create Tokens</h3>
  <div>Once Nuron is running on your machine, you can now programmatically create tokens with simple JavaScript code.</div>
  <blockquote><h4>Create vs. Mint</h3><br>One of the most important distinguishing factors of Cell is that, "creating" a token and "minting" a token are separate steps.<br><br>This unbundling makes the engine ultra-flexible.<br><br><b>Example 1:</b> A collection creator may create 1000 tokens and publish them on a website, and minters may come to the site and "mint" them later.<br><br><b>Example 2:</b> A minter may request a collection creator to "create" a custom token. When the creator creates and returns the signed token to the minter, the minter can then "mint" it to the blockchain.<br><br><b>Example 3:</b> A collection creator may create a token privately and give it to someone privately WITHOUT publishing anywhere (through social media DMs, emails, text messages, etc). The receiver can then mint the token when they want.</blockquote>
  <br>
  <div>In this section, we will walk through 3 code examples to create NFTs programmatically.</div>
  <br>
  <div class='section'>
    <h4>1. Generative Avatar NFTs</h4>
    <br>
    <div>In this example we will create 100 generative avatar NFTs for this collection, including the minting page. It will look something like this:</div>
    <img src="/cellstore.png">
    <br>
    <div>First install all dependencies:</div>
    <pre class='code'>npm install nuronjs @dicebear/open-peeps @dicebear/avatars</pre>
    <div>Then create a file named <code>index.js</code>:</div>
    <pre class='code h'><code>{{code0}}</code></pre>
    <div>Run the code:</div>
    <pre class='code'>node index</pre>
    <div>Above code takes care of everything you need for an NFT collection, including:</div>
    <ol>
      <li>Store files locally</li>
      <li>Create tokens locally</li>
      <li>Publish all the files to the global IPFS network (pinning)</li>
    </ol>
    <div>All that's left now is to to publish the tokens to the web so people can mint them.</div>
    <blockquote>To learn how to actually publish the NFTs and the storefront website, skip to the next section "Browse and Manage Tokens"</blockquote>
  </div>
  <div class='section'>
    <h4>2. Create 100 Tokens Programmatically</h4>
    <br>
    <div>First install all dependencies:</div>
    <pre class='code'>npm install nuronjs axios</pre>
    <div>Then create a file named <code>index.js</code>:</div>
    <pre class='code h'><code>{{code}}</code></pre>
    <div>Run the code:</div>
    <pre class='code'>node index</pre>
    <div>Above code takes care of everything you need for an NFT collection, including:</div>
    <ol>
      <li>Store files locally</li>
      <li>Create tokens locally</li>
      <li>Publish all the files to the global IPFS network (pinning)</li>
    </ol>
    <div>All that's left now is to to publish the tokens to the web so people can mint them.</div>
    <blockquote>To learn how to actually publish the NFTs and the storefront website, skip to the next section "Browse and Manage Tokens"</blockquote>
  </div>
  <div class='section'>
    <h4>2. Tokenize all images inside a folder</h4>
    <br>
    <div>First install all dependencies:</div>
    <pre class='code'>npm install nuronjs</pre>
    <div>Then create a file named <code>index.js</code>:</div>
    <pre class='code h'><code>{{code2}}</code></pre>
    <div>Run the code:</div>
    <pre class='code'>node index [IMAGE_FOLDER_PATH]</pre>
    <div>Above code takes care of everything you need for an NFT collection, including:</div>
    <ol>
      <li>Store files locally</li>
      <li>Create tokens locally</li>
      <li>Publish all the files to the global IPFS network (pinning)</li>
    </ol>
    <div>All that's left now is to to publish the tokens to the web so people can mint them.</div>
    <blockquote>To learn how to actually publish the NFTs and the storefront website, read the next section "Browse and Manage Tokens"</blockquote>
  </div>
</div>
<hr>
<div>
  <h3>3. Browse and Manage Tokens</h3>
  <div>Any signed token can be submitted to the blockchain to be minted. To mint tokens, we will use <code>c0.js</code>, a library that lets you interact with the Cell C0 contract on the blockchain.</div>
  <div class='section'>
    <h4>1. Where are the tokens stored?</h4>
    <br>
    <div>So where are all the files stored? Run the following command to find out:</div>
    <pre class='code'>nuron home</pre>
    <div>Open the folder with Finder (mac) or Explorer (windows) or ls (linux) and you will see all the files you've just created.</div>
    <pre class='code'>.
├─ config.json
└─ fs
   └─ {{name}}
      ├─ db.sqlite3
      ├─ index.html
      ├─ token.html
      └─ ipfs
         ├─ file (token, metadata, asset files, etc.)
         ├─ file (token, metadata, asset files, etc.)
         ├─ ...
         └─ file (token, metadata, asset files, etc.)</pre>
    <ol>
      <li><code>db.sqlite3</code>: stores all the token JSON in sqlite, so they can be queried in realtime, but also shared easily in a single file</li>
      <li><code>index.html</code>: the main page that displays all the tokens under the folder. It loads the <code>db.sqlite3</code> database once when the page loads, and queries the in-browser DB to load tokens and render them.</li>
      <li><code>token.html</code>: the page used to render and mint the tokens.</li>
      <li><code>ipfs</code>: the ipfs folder stores all the files (including the asset files, metadata files, and even the token files) under the IPFS names WITHOUT publishing anything to the global IPFS network. You will need to pin these files to IPFS if you want them to be public at some point.</li>
    </ol>
  </div>
  <div class='section'>
    <h4>2. Testing locally</h4>
    <br>
    <div>Remember we called the <code>nuron.web.build()</code> method in the creation code? This was what created the <code>index.html</code> and the <code>token.html</code> files.</div>
    <ol>
      <li><code>index.html</code>: creates the storefront homepage</li>
      <li><code>token.html</code>: creates the landing page that renders each token individually</li>
    </ol>
    <blockquote>You don't have to use these auto-generated pages. They are just provided for convenience.</blockquote>
    <div>Before publishing these sites, let's check to make sure the pages load correctly.</div>
    <br>
    <div>Let's first check what folders are contained within the Nuron file system:</div>
    <pre class='code'>nuron ls</pre>
    <div>This will list all the folders. We want to start a local HTTP server for one of the folders, in this case <code>{{name}}</code>:</div>
    <pre class='code'>nuron serve {{name}}</pre>
    <div>This command internally uses <a href="https://github.com/http-party/http-server">HTTP-SERVER</a> module to serve local files from a local web server. The terminal will look something like this:</div>
    <pre class='code'>Starting up http-server, serving /root/_nuron/home/fs/open-peeps

http-server version: 14.1.0

http-server settings:
CORS: disabled
Cache: 3600 seconds
Connection Timeout: 120 seconds
Directory Listings: visible
AutoIndex: visible
Serve GZIP Files: false
Serve Brotli Files: false
Default File Extension: none

Available on:
  http://127.0.0.1:8080
  http://165.22.187.55:8080
  http://10.10.0.15:8080
  http://172.17.0.1:8080
  http://172.28.0.1:8080
Hit CTRL-C to stop the server</pre>
    <br>
    <div>Let's test now. Open the server URL in the browser (for this example it's http://127.0.0.1:8080), and you will see the storefront landing page.</div>
    <br>
    <div>For the generative avatar example, it will look something like this:</div>
    <img src="/cellstore.png">
  </div>
  <div class='section'>
    <h4>3. Testing publicly (advanced)</h4>
    <br>
    <div>The problem with the local test is that <b>ONLY YOU can access the website</b>, since you're loading the website from your own local machine. No one else can just type in <code>http://127.0.0.1:8080</code> from their machines and access your website.</div>
    <br>
    <div>While testing, you may often want to have a temporary REAL URL that anyone else can access (such as <code>https://fluffy-hound-53.loca.lt/</code>), so you can privately test with your friends or colleagues. Some possible scenarios:</div>
    <ol>
      <li><b>Private sharing:</b> Quickly share the minting page with a small group of people who have the URL</li>
      <li><b>Test on a remote linux machine:</b> If you're running Nuron on a remote linux machine (like Digitalocean), you can't just type in <code>http://127.0.0.1:8080</code> in your browser to access the website because the <code>http://127.0.0.1:8080</code> on your machine is your own machine, not the remote linux machine.</li>
    </ol>
    <div>To solve this problem, you can set up a temporary public URL that connects to the instant HTTP server you created with <code>nuron serve [folder]</code>. Just get the port number from the <code>nuron serve</code> (let's assume the port is 8080 in this case) and run the following command, which creates a public URL "tunnel" that connects to the local IP:</div>
    <pre class='code'>nuron tunnel 8080</pre>
    <div>It will start a tunnel and print the public URL you can use, for example:</div>
    <pre class='code'>Tunnel created:  https://fluffy-hound-53.loca.lt</pre>
    <blockquote>Nuron makes use of the free <a href="https://theboroer.github.io/localtunnel-www/">Localtunnel</a> service to handle tunneling.</blockquote>
  </div>
  <div class='section'>
    <h4>4. Going LIVE</h4>
    <br>
    <div>The Cell protocol has been carefully designed to remove centralization points. By default everything works as a static website, with no centralized database running somewhere in the cloud.</div>
    <br>
    <div>Everything is packaged in a way that should "just work". So how do we publish this thing and allow people to mint?</div>
    <ol>
      <li><b>Basic:</b> Just dump the entire collection folder onto your web hosting provider, and it should just work. For example if everything is stored under <code>/root/_nuron/home/fs/open-peeps</code>, you simply copy and paste that entire <code>open-peeps</code> folder into whichever web hosting provider you use, and it should work instantly.</li>
      <li><b>GitHub Pages:</b> Every folder in the Nuron file system is a git repository, and was designed to work right out of the box with no additional configuration. You can publish your NFT collection to the web for free using GitHub pages. To use GitHub pages, you can:
        <ol>
          <li>download <a href="https://desktop.github.com/">GitHub Desktop</a> and login with your GitHub account</li>
          <li>Add your NFT collection folder (example: <code>/root/_nuron/home/fs/open-peeps</code>), commit, and publish to GitHub</li>
          <li>Go to GitHub and <a href="https://docs.github.com/en/pages/getting-started-with-github-pages/configuring-a-publishing-source-for-your-github-pages-site">turn on GitHub pages for your repository</a></li>
        </ol>
      </li>
    </ol>
  </div>
</div>
<hr>
<div>
  <h3>4. Minting Tokens</h3>
  <div>Once you publish the tokens to a website, you're pretty much done. Anyone can now come and mint the tokens they have the permission to.</div>
  <blockquote>With Cell, each token can be individually programmed to have different minting conditions and traits from one another, such as royalty, expiration time, start time, price, hash puzzle, membership, etc.</blockquote>
  <div class='section'>
    <h4>1. Mint from the storefront</h4>
    <br>
    <div>The included <code>index.html</code> and <code>token.html</code> are enough to let people mint directly from the website. Before moving forward, try minting from the site.</div>
  </div>
  <div class='section'>
    <h4>2. c0.js</h4>
    <br>
    <div>You need to use <code>c0.js</code> to interact with the Cell C0 contract. The built-in web pages (<code>index.html</code> and <code>token.html</code>) both make use of the <code>c0.js</code> library to achieve this as well.</div>
    <br>
    <div>To learn more about how to use <code>c0.js</code>, check out the <a href="https://c0js.cell.computer">c0.js documentation</a></div>
  </div>
</div>
<hr>
<div>
  <h3>5. More info</h3>
  <div class='section'>
    <h4>1. API Docs</h4>
    <blockquote><a target="_blank" href="https://nuronjs.cell.computer">Nuron.js</a>: Nuron RPC client for JavaScript</blockquote>
    <blockquote><a target="_blank" href="https://nuron.cell.computer">Nuron</a>: Nuron RPC specification</blockquote>
    <blockquote><a target="_blank" href="https://c0js.cell.computer">c0.js</a>: JavaScript library for interacting with the Cell C0 contract</blockquote>
  </div>
  <div class='section'>
    <h4>2. How do folders work?</h4>
    <ol>
      <li>You can create as many folders as you want, for whatever purpose you want.</li>
      <li>You can even create multiple different folders for the same contract.</li>
      <li>When you initialize a Nuron object, you can specify which folder you're going to be saving to (example below).</li>
    </ol>
    <pre class='code h'><code>// This nuron instance will write to the folder "cube"
const nuron1 = new Nuron({
  key: "m'/44'/60'/0'/0/0",
  fs: "cube",
  domain: {{{domainLine}}}
});

// This nuron instance will write to the folder "canvas"
const nuron2 = new Nuron({
  key: "m'/44'/60'/0'/0/0",
  fs: "canvas",
  domain: {{{domainLine}}}
});</code></pre>
  </div>
  <div class='section'>
    <h4>3. Nuron commands</h4>
    <ol>
      <li><code>nuron stop</code>: shut down nuron</li>
      <li><code>nuron ls</code>: list all folders in the nuron file system</li>
      <li><code>nuron serve [folder_name]</code>: start a local web server from the folder</li>
      <li><code>nuron tunnel [port]</code>: connect the local web server to a temporary public URL (to allow others to test privately)</li>
    </ol>
  </div>
  <div class='section'>
    <h4>4. On-demand NFTs</h4>
    <br>
    <div>This documentation mostly discussed how to create all tokens BEFOREHAND, and let people mint from the created tokens published to the web.</div>
    <br>
    <div>However, one of the biggest benefits of the Cell protocol approach is that the <b>creating and minting of a token are unbundled and exist as separate steps</b>, which means you can create tokens on one machine, and mint them on another machine. This lets us easiliy implement on-demand minting apps.</div>
    <br>
    <div>For example, let's say you wanted to build something like the <a href="https://canvas.papercorp.org">Canvas NFT</a>, where the users can customize what they want to mint. You can achieve this by:</div>
    <ol>
      <li>create a web app server (for example using <a href="https://expressjs.com/">express.js</a></li>
      <li>let people do whatever they want on the frontend side, and send a POST request with a desired payload</li>
      <li>your server side logic can call the <code>nuron.token.create()</code> to create custom tokens requested by the frontend</li>
      <li>the server can then return the created token to the frontend as the request response</li>
      <li>the user can then take that JSON (signed token object) and mint it.</li>
    </ol>
    <div>Let's take the <code>open-peeps</code> generative avatar example from above, and turn it into an on-demand minting app.</div>
    <br>
    <div>First, create a new project folder and install all the dependencies:</div>
    <pre class='code'>npm install @dicebear/avatars @dicebear/open-peeps express nuronjs</pre>
    <div>Now create a file named <code>index.js</code>:</div>
    <pre class='code h'><code>const { createAvatar } = require('@dicebear/avatars');
const style = require('@dicebear/open-peeps');
const Nuron = require('nuronjs')
const express = require('express')
const nuron = new Nuron({
  key: "m'/44'/60'/0'/0/0",
  fs: "open-peeps",
  domain: {{{domainLine}}}
});
const app = express()
app.use(express.urlencoded({ extended: true }))
app.use(express.json())
app.get("/", (req, res) => {
  res.sendFile(__dirname + "/index.html")
})
app.post("/create", async (req, res) => {
  // use the seed payload
  let seed = req.body.seed
  // generate svg
  let svg = createAvatar(style, { seed: req.body.seed });
  // save the svg to nuron and get its cid
  let svg_cid = await nuron.fs.save(Buffer.from(svg))
  // save the metadata to nuron and get its cid
  let metadata_cid = await nuron.fs.save({
    name: seed,
    description: `${seed}.svg`,
    image: `ipfs://${svg_cid}`,
    mime: { [svg_cid]: "image/svg+xml" }
  })
  // create a token from the metadata cid
  let token = await nuron.token.create({
    cid: metadata_cid
  })
  // await nuron.token.save(token)  // saving tokens to nuron are optional if they will be minted immediately
  await nuron.fs.pin("ipfs/" + svg_cid)
  await nuron.fs.pin("ipfs/" + metadata_cid)
  console.log("pinned")
  // return the token as response.
  // the user will take this token and mint it from the front end
  res.json({
    token: token,
    svg: svg
  })
})
app.listen(3000)</code></pre>
    <div>Above code basically sets up an express.js server and when a <code>POST /create</code> request is made, it creates a token and returns it back to the frontend along with the SVG.</div>
    <br>
    <div>Now we need the frontend page. Create a file named <code>index.html</code> in the same folder:</div>
    <pre class='code h'><code>&lt;html&gt;
&lt;head&gt;
&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/web3/1.7.1-rc.0/web3.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/c0js/dist/c0.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form&gt;
&lt;input type='text' id='seed'&gt;
&lt;input type='submit' value='create'&gt;
&lt;/form&gt;
&lt;div id='svg'&gt;&lt;/div&gt;
&lt;div id='tokens'&gt;
&lt;/div&gt;
&lt;script&gt;
document.querySelector(&quot;form&quot;).addEventListener(&quot;submit&quot;, async (e) =&gt; {
  e.preventDefault()
  e.stopPropagation()
  // initialize c0 with the browser web3 instance
  const web3 = new Web3(window.ethereum);
  const c0 = new C0()
  await c0.init({ web3: web3 })
  // call &quot;POST /create&quot; endpoint to generate a token
  let response = await fetch(&quot;/create&quot;, {
    method: &quot;POST&quot;,
    headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },
    body: JSON.stringify({ seed: document.querySelector(&quot;#seed&quot;).value })
  }).then((res) =&gt; {
    return res.json()
  })
  let svg = response.svg
  let token = response.token
  document.querySelector(&quot;#svg&quot;).innerHTML = svg
  // create a mint transaction with one token
  let tx = await c0.token.mint([token])
  let address = token.domain.verifyingContract
  let tokenId = token.body.id
  if (token.domain.chainId == 4) {
    // rinkeby
    document.querySelector(&quot;#tokens&quot;).innerHTML = `&lt;div class='markets'&gt;
  &lt;a href=&quot;https://testnets.opensea.io/assets/${address}/${tokenId}&quot;&gt;Opensea&lt;/a&gt;
  &lt;a href=&quot;https://rinkeby.rarible.com/token/${address}:${tokenId}&quot;&gt;Rarible&lt;/a&gt;
&lt;/div&gt;`
  } else {
    // mainnet
    document.querySelector(&quot;#tokens&quot;).innerHTML = `&lt;div class='markets'&gt;
  &lt;a href=&quot;https://opensea.io/assets/${address}/${tokenId}&quot;&gt;Opensea&lt;/a&gt;
  &lt;a href=&quot;https://rarible.com/token/${address}:${tokenId}&quot;&gt;Rarible&lt;/a&gt;
&lt;/div&gt;`
  }
})
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
  <br>
  <div>Now start the server and go to <a href="http://localhost:3000">http://localhost:3000</a>:</div>
  <pre class='code'>node index</pre>
  <br>
  <div>The entire minting app will look something like this:</div>
  <br>
  <img src="ondemand.gif">
  </div>
</div>
</script>
<script id="code0-template" type="text/x-handlebars-template">
const { createAvatar } = require('@dicebear/avatars');
const style = require('@dicebear/open-peeps');
const Nuron = require('nuronjs')
const nuron = new Nuron({
  key: "m'/44'/60'/0'/0/0",
  fs: "open-peeps",
  domain: {{{domain}}}
});
(async () => {
  // Loop 100 times and make avatars
  for(let i=0; i<100; i++) {
    // Call the dicebear library to create avatar SVG. See https://avatars.dicebear.com/styles/open-peeps
    let svg = createAvatar(style, { seed: i.toString() });
    // Save the SVG to Nuron
    let svg_cid = await nuron.fs.save(Buffer.from(svg))
    // Create a metadata from the SVG and save it to Nuron
    let metadata_cid = await nuron.fs.save({
      name: `${i}`,
      description: `${i}.svg`,
      image: `ipfs://${svg_cid}`,
      mime: { [svg_cid]: "image/svg+xml" }
    })
    // Create a token from the metadata IPFS cid
    let token = await nuron.token.create({
      cid: metadata_cid
    })
    // Save the token to Nuron
    await nuron.token.save(token)
    // Pin all the metadata files and svg files
    await nuron.fs.pin("ipfs/" + metadata_cid)
    await nuron.fs.pin("ipfs/" + svg_cid)
    console.log("created", i)
  }
  // Build "index.html" and "token.html" storefront pages
  await nuron.web.build()
})();
</script>
<script id="code-template" type="text/x-handlebars-template">
const Nuron = require('nuronjs');
const axios = require('axios');
const nuron = new Nuron({
  key: "m'/44'/60'/0'/0/0",
  fs: "this_cat",
  domain: {{{domain}}}
});
(async () => {
  let cids = []
  // creating 100 tokens
  for(let i=0; i<100; i++) {
    // fetch image into buffer
    const image = await axios({ url: "https://thiscatdoesnotexist.com/", method: "GET", responseType: 'arraybuffer' }).then((r) => { return r.data })
    // save the image buffer and get its IPFS cid
    const cid = await nuron.fs.save(image)
    // save metadata and get its IPFS cid
    const metacid = await nuron.fs.save({
      name: i,
      description: i,
      image: "ipfs://" + cid,
    })
    // create a token from the metadata cid (price 0)
    const token = await nuron.token.create({
      cid: metacid,
      price: 0
    })
    // save the token
    const tokencid = await nuron.token.save(token)
    // keep track of the file cid and the metadata cid so we can pin them below
    cids.push(cid)
    cids.push(metacid)
  }
  // build the default landing pages (index.html and token.html)
  await nuron.web.build()
  // pin all the files
  for(let i=0; i<cids.length; i++) {
    // pin the files at path "ipfs/:cid" => this is where all the IPFS files are stored
    let res = await nuron.fs.pin("ipfs/" + cids[i])
    console.log("pinned", i, "of", cids.length, res)
  }
})();
</script>
<script id="code2-template" type="text/x-handlebars-template">
const fs = require('fs')
const path = require('path')
const Nuron = require('nuronjs');
const nuron = new Nuron({
  key: "m'/44'/60'/0'/0/0",
  fs: "tokenized_images",
  domain: {{{domain}}}
});
const tokenize = async (folder) => {
  let cids = []
  // get all files under the "folder" location
  const files = await fs.promises.readdir(folder)
  // loop through all the filenames
  for(let file of files) {
    // read the file into buffer
    const buf = await fs.promises.readFile(path.resolve(folder, file))
    // save the buffer and get its IPFS cid
    const cid = await nuron.fs.save(buf)
    // save metadata to the file system and get its IPFS cid
    const metacid = await nuron.fs.save({
      name: file,
      image: "ipfs://" + cid,
    })
    // create a token object
    const token = await nuron.token.create({
      cid: metacid,
      price: 0
    })
    // save the token
    const tokencid = await nuron.token.save(token)
    // store the image file cid and the metadata file cid so we can pin them below.
    cids.push(cid)
    cids.push(metacid)
  }
  // build the default landing page
  await nuron.web.build()
  // pin all the files
  for(let cid of cids) {
    await nuron.token.pin(cid)
  }
}

// take the command line folder argument and tokenize all images under that folder
tokenize(process.argv[2])
</script>
<script>
const index = parseInt(location.hash.slice(1))
const source0 = document.getElementById("code0-template").innerHTML.trim();
const source1 = document.getElementById("empty-template").innerHTML;
const source2 = document.getElementById("deployed-template").innerHTML;
const source3 = document.getElementById("code-template").innerHTML.trim();
const source4 = document.getElementById("code2-template").innerHTML.trim();
const empty_template = Handlebars.compile(source1);
const deployed_template = Handlebars.compile(source2);
const code_template = Handlebars.compile(source3);
const code2_template = Handlebars.compile(source4);
const code0_template = Handlebars.compile(source0);
document.addEventListener("DOMContentLoaded", async () => {
  const web3 = new Web3(window.ethereum);
  const chainId = await web3.eth.getChainId()
  const network = (chainId === 4 ? "rinkeby" : "mainnet")
  document.querySelector(".network").innerHTML = network
  const factory = Config[network]
  const c0 = new C0()
  await c0.init({ web3, });
  let implementation = await c0.collection.methods(factory).implementation().call()
  const addresses = await c0.collection.find({
    factory,
    implementation,
    creator: c0.account,
    start: index,
    count: 1
  })
  const address = addresses[0]
  let domain = ""
  let domainLine = ""
  try {
    const methods = c0.token.methods(address)
    let name = await methods.name().call()
    let symbol = await methods.symbol().call()
    let chainId = await web3.eth.getChainId()
    domain = JSON.stringify({
      address,
      chainId,
      name
    }, null, 2)
    domainLine = JSON.stringify({
      address,
      chainId,
      name
    })
    const code = code_template({ domain: domainLine, name })
    const code2 = code2_template({ domain: domainLine, name })
    const code0 = code0_template({ domain: domainLine, name })
//    document.querySelector("#info").innerHTML = deployed_template({ name, symbol, domain, code, code2, domainLine, code0 })

    // "deploy" button
    // instructions on how to get started (like github)
    document.querySelector("header").innerHTML = `<h3><i class="fa-solid fa-folder-open"></i> ${address}</h3>
  <h4>${name} (${symbol})</h4>
<br>
<div class='section'>
<h4>domain</h4>
<pre class='code'>${domain}</pre></div>`
  } catch (e) {

/*
    document.querySelector("#info").innerHTML = empty_template()
    document.querySelector("header").innerHTML = `<h3><i class="fa-solid fa-folder-open"></i> ${address}</h3>`
    */

    //document.querySelector("#form").innerHTML = empty_template()
    let name = "(contract name)"
    let symbol = "(contract symbol)"
    let chainId = await web3.eth.getChainId()
    domain = JSON.stringify({
      address,
      chainId,
      name
    }, null, 2)
    domainLine = JSON.stringify({
      address,
      chainId,
      name
    })
    console.log("domainLine", domainLine)
    const code = code_template({ domain: domainLine, name })
    const code2 = code2_template({ domain: domainLine, name })
    const code0 = code0_template({ domain: domainLine, name })
//    document.querySelector("#info").innerHTML = deployed_template({ name, symbol, domain, code, code2, domainLine, code0 })
    document.querySelector("header").innerHTML = `<h3><i class="fa-solid fa-folder-open"></i> ${address}</h3>${empty_template()}`




    document.querySelector("form#deploy").addEventListener("submit", async (e) => {
      e.preventDefault()
      e.stopPropagation()
      let name = document.querySelector("#name").value 
      let symbol = document.querySelector("#symbol").value 
      if (name.length === 0) {
        alert("name must not be empty")
        return
      }
      if (name.length === 0) {
        alert("symbol must not be empty")
        return
      }
      document.querySelector(".loading").classList.remove("hidden")
      document.querySelector("#submit").classList.add("hidden")
      let tx = await c0.collection.create({
        factory,
        index,
        name,
        symbol
      })
      console.log("tx", tx)
      location.reload()
    })
  }
  if (Config.private) {
    let info = await fetch("/privateclub").then((r) => { return r.json() })
    let tokenURI = info.tokenURI
    let metadata = await fetch("https://ipfs.io/ipfs/" + info.tokenURI.replace("ipfs://", "")).then((r) => {
      return r.json()
    })
    document.querySelector("#user").src = "https://ipfs.io/ipfs/" + metadata.image.replace("ipfs://", "")
  }
  hljs.highlightAll();
})
</script>
</head>
<body>
<nav>
  <a href="/"><img class='logo' src='/cell_icon.png'></a>
  <div class='flexible'></div>
  <a class='block' href="/settings">
    <span class='network'></span>
    <img id='user'>
  </a>
</nav>
<div class='container'>
  <header></header>
  <div id='info'>
    <h1>Get Started</h1>
    <a href="https://tutorial.cell.computer">Check out the Cell tutorial</a>
  </div>
</div>
</body>
</html>
